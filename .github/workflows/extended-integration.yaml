name: Extended Integration

# Full integration tests - runs on merge to main, nightly, or ArgoCD/platform/observability PRs
# For fast PR validation, see pr-validation.yaml
# Deployment is GitOps-driven: ArgoCD manages all cluster resources

on:
  push:
    branches: [main]
  schedule:
    - cron: '0 6 * * *'  # Daily at 6 AM UTC
  workflow_dispatch: {}
  pull_request:
    branches: [main]
    paths:
      - 'argocd/**'
      - 'platform/**'
      - 'observability/**'
      - 'apps/**'
      - 'scripts/argocd-*.sh'
      - 'scripts/cluster-*.sh'
      - 'scripts/stack-*.sh'

jobs:
  lint:
    name: Lint
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install yamllint
        run: pip install yamllint

      - name: Run yamllint
        run: |
          echo "Running yamllint..."
          yamllint -c .yamllint.yaml . && echo "YAML lint: PASSED"

      - name: Validate Makefile exists
        run: |
          test -f Makefile && echo "Makefile exists" || exit 1

      - name: Show make targets
        run: make help

  # Extended integration test - validates full stack via ArgoCD GitOps
  # ArgoCD manages all resources: platform, observability, and workloads
  # Sync waves ensure correct deployment order
  integration-test:
    name: Extended Integration
    runs-on: ubuntu-latest
    needs: lint
    timeout-minutes: 25
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Create k3d cluster
        uses: AbsaOSS/k3d-action@v2.4.0
        with:
          cluster-name: automation-k8s
          k3d-version: v5.7.4
          args: --config clusters/k3d/cluster-config.yaml

      - name: Install Helm and tools
        run: |
          curl -fsSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
          helm version
          jq --version

      # ===== ARGOCD GITOPS DEPLOYMENT =====
      - name: Bootstrap ArgoCD
        run: make argocd-up

      - name: Verify ArgoCD is running
        run: |
          echo "Verifying ArgoCD components..."
          # Wait for specific deployments (excludes Completed job pods)
          kubectl wait --for=condition=Available deployment/argocd-server -n argocd --timeout=180s
          kubectl wait --for=condition=Available deployment/argocd-repo-server -n argocd --timeout=180s
          kubectl wait --for=condition=Available deployment/argocd-applicationset-controller -n argocd --timeout=180s
          kubectl wait --for=condition=Ready pod -l app.kubernetes.io/name=argocd-application-controller -n argocd --timeout=180s
          echo "ArgoCD is ready"

      - name: Apply root application
        run: |
          echo "Applying root app-of-apps..."
          kubectl apply -f argocd/applications/root-app.yaml
          echo "Root application applied"

      - name: Wait for ArgoCD sync (platform layer)
        run: |
          # Helper function: wait for pods to exist, then wait for them to be ready
          wait_for_pods() {
            local namespace="$1"
            local label="$2"
            local timeout="${3:-180}"
            local description="${4:-pods}"

            echo "Waiting for $description to be created..."
            local elapsed=0
            while [[ $elapsed -lt $timeout ]]; do
              if kubectl get pods -n "$namespace" -l "$label" 2>/dev/null | grep -q .; then
                echo "$description found, waiting for Ready..."
                kubectl wait --for=condition=Ready pods -l "$label" -n "$namespace" --timeout="${timeout}s"
                return $?
              fi
              sleep 5
              elapsed=$((elapsed + 5))
              echo "  Still waiting for $description... (${elapsed}s)"
            done
            echo "Timeout waiting for $description to be created"
            return 1
          }

          echo "Waiting for platform components to sync..."

          # Wait for Istio CRDs first (sync wave 0)
          echo "Waiting for Istio base CRDs..."
          timeout 180 bash -c 'until kubectl get crd gateways.networking.istio.io 2>/dev/null; do sleep 5; done'

          # Wait for Istio control plane (sync wave 1)
          wait_for_pods "istio-system" "app=istiod" 180 "Istiod"

          # Wait for cert-manager (sync wave 2)
          echo "Waiting for cert-manager namespace..."
          timeout 180 bash -c 'until kubectl get ns cert-manager 2>/dev/null; do sleep 5; done'
          wait_for_pods "cert-manager" "app.kubernetes.io/instance=cert-manager" 180 "cert-manager"

          # Wait for Istio gateway (sync wave 4) - uses istio=gateway label (matches Gateway selector)
          echo "Waiting for istio-ingress namespace..."
          timeout 180 bash -c 'until kubectl get ns istio-ingress 2>/dev/null; do sleep 5; done'
          wait_for_pods "istio-ingress" "istio=gateway" 180 "Istio gateway"

          echo "Platform layer synced"

      - name: Wait for ArgoCD sync (observability layer)
        run: |
          # Helper function: check ArgoCD app status with full details
          check_argocd_app() {
            local app="$1"
            local sync=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
            local health=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
            local phase=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "Unknown")
            local message=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.operationState.message}' 2>/dev/null || echo "")
            echo "$app: sync=$sync, health=$health, phase=$phase"
            if [[ -n "$message" && "$message" != "null" ]]; then
              echo "  Message: $message"
            fi
            # Show conditions if any (includes errors)
            local conditions=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.conditions}' 2>/dev/null || echo "")
            if [[ -n "$conditions" && "$conditions" != "null" && "$conditions" != "[]" ]]; then
              echo "  Conditions: $conditions"
            fi
            # Show source status for multi-source apps
            local sourceStatus=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.sourceStatus}' 2>/dev/null || echo "")
            if [[ -n "$sourceStatus" && "$sourceStatus" != "null" ]]; then
              echo "  Source Status: $sourceStatus"
            fi
            # Check for refresh errors
            local refreshErr=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.reconciledAt}' 2>/dev/null || echo "")
            echo "  Last Reconciled: $refreshErr"
          }

          # Helper function: wait for ArgoCD app to sync with diagnostics
          wait_for_argocd_app() {
            local app="$1"
            local timeout="${2:-300}"
            local description="${3:-$app}"

            echo "Waiting for $description ArgoCD app to sync..."
            local elapsed=0
            while [[ $elapsed -lt $timeout ]]; do
              local sync=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.sync.status}' 2>/dev/null || echo "Unknown")
              local health=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.health.status}' 2>/dev/null || echo "Unknown")
              local phase=$(kubectl get application "$app" -n argocd -o jsonpath='{.status.operationState.phase}' 2>/dev/null || echo "Unknown")

              # Check for sync errors or failures
              if [[ "$phase" == "Failed" || "$phase" == "Error" ]]; then
                echo "ERROR: $description sync failed!"
                check_argocd_app "$app"
                # Show detailed conditions
                kubectl get application "$app" -n argocd -o jsonpath='{.status.conditions}' 2>/dev/null | jq '.' || true
                return 1
              fi

              # Check if healthy
              if [[ "$sync" == "Synced" && "$health" == "Healthy" ]]; then
                echo "$description synced and healthy"
                return 0
              fi

              # Progress update every 30s
              if (( elapsed % 30 == 0 )); then
                echo "  [$elapsed/${timeout}s] $app: sync=$sync, health=$health, phase=$phase"
              fi

              sleep 10
              elapsed=$((elapsed + 10))
            done

            echo "Timeout waiting for $description to sync"
            check_argocd_app "$app"
            echo ""
            echo "=== ArgoCD repo-server logs (last 30 lines) ==="
            kubectl logs deployment/argocd-repo-server -n argocd --tail=30 2>/dev/null || echo "Could not get repo-server logs"
            echo ""
            echo "=== ArgoCD application-controller logs (last 30 lines) ==="
            kubectl logs statefulset/argocd-application-controller -n argocd --tail=30 2>/dev/null || echo "Could not get controller logs"
            return 1
          }

          # Helper function: wait for pods to exist, then wait for them to be ready
          wait_for_pods() {
            local namespace="$1"
            local label="$2"
            local timeout="${3:-180}"
            local description="${4:-pods}"

            echo "Waiting for $description to be created..."
            local elapsed=0
            while [[ $elapsed -lt $timeout ]]; do
              if kubectl get pods -n "$namespace" -l "$label" 2>/dev/null | grep -q .; then
                echo "$description found, waiting for Ready..."
                kubectl wait --for=condition=Ready pods -l "$label" -n "$namespace" --timeout="${timeout}s"
                return $?
              fi
              sleep 5
              elapsed=$((elapsed + 5))
              echo "  Still waiting for $description... (${elapsed}s)"
            done
            echo "Timeout waiting for $description to be created"
            return 1
          }

          echo "Waiting for observability components to sync..."

          # Wait for observability namespace
          echo "Waiting for observability namespace..."
          timeout 180 bash -c 'until kubectl get ns observability 2>/dev/null; do sleep 5; done'

          # Wait for prometheus-grafana ArgoCD app to sync first
          echo ""
          echo "=== Checking ArgoCD observability apps status ==="
          check_argocd_app "prometheus-grafana-prereqs"
          check_argocd_app "prometheus-grafana"
          check_argocd_app "prometheus-grafana-resources"
          check_argocd_app "loki"
          echo ""

          # Wait for ArgoCD to sync prometheus-grafana with detailed diagnostics
          wait_for_argocd_app "prometheus-grafana" 300 "Prometheus/Grafana"

          # Wait for Prometheus pods
          wait_for_pods "observability" "app.kubernetes.io/name=prometheus" 120 "Prometheus"

          # Wait for Grafana pods
          wait_for_pods "observability" "app.kubernetes.io/name=grafana" 120 "Grafana"

          echo "Observability layer synced"

      - name: Wait for ArgoCD sync (workloads layer)
        run: |
          # Helper function: wait for pods to exist, then wait for them to be ready
          wait_for_pods() {
            local namespace="$1"
            local label="$2"
            local timeout="${3:-180}"
            local description="${4:-pods}"

            echo "Waiting for $description to be created..."
            local elapsed=0
            while [[ $elapsed -lt $timeout ]]; do
              if kubectl get pods -n "$namespace" -l "$label" 2>/dev/null | grep -q .; then
                echo "$description found, waiting for Ready..."
                kubectl wait --for=condition=Ready pods -l "$label" -n "$namespace" --timeout="${timeout}s"
                return $?
              fi
              sleep 5
              elapsed=$((elapsed + 5))
              echo "  Still waiting for $description... (${elapsed}s)"
            done
            echo "Timeout waiting for $description to be created"
            return 1
          }

          echo "Waiting for workload applications to sync..."

          # Wait for namespaces
          echo "Waiting for home-automation namespace..."
          timeout 120 bash -c 'until kubectl get ns home-automation 2>/dev/null; do sleep 5; done'

          # Wait for Home Automation components
          wait_for_pods "home-automation" "app.kubernetes.io/name=mosquitto" 120 "Mosquitto MQTT"
          wait_for_pods "home-automation" "app.kubernetes.io/name=homeassistant" 180 "HomeAssistant"

          # Wait for sample app
          echo "Waiting for ingress-sample namespace..."
          timeout 120 bash -c 'until kubectl get ns ingress-sample 2>/dev/null; do sleep 5; done'
          wait_for_pods "ingress-sample" "app=httpbin" 120 "sample app"

          echo "Workloads layer synced"

      # ===== CRITICAL: ArgoCD Health Verification =====
      # This step MUST pass - catches AppProject restrictions, CRD issues, selector mismatches
      - name: Verify ArgoCD applications are healthy
        run: |
          chmod +x scripts/argocd-health-test.sh
          scripts/argocd-health-test.sh

      # ===== HELM TESTS =====
      # Run Helm tests for charts that have built-in test suites
      - name: Run Helm tests
        run: |
          chmod +x scripts/helm-test.sh
          scripts/helm-test.sh

      # ===== VERIFICATION TESTS =====
      - name: Verify Istio mTLS
        run: |
          MTLS_MODE=$(kubectl get peerauthentication default -n istio-system -o jsonpath='{.spec.mtls.mode}' 2>/dev/null || echo "NOTFOUND")
          if [ "$MTLS_MODE" = "STRICT" ]; then
            echo "✓ mTLS STRICT verified"
          else
            echo "✗ mTLS mode: $MTLS_MODE (expected STRICT)"
            exit 1
          fi

      - name: Verify cert-manager
        run: |
          echo "Checking ClusterIssuers..."
          kubectl get clusterissuers
          echo "Checking Certificates..."
          kubectl get certificates -A
          # Verify at least the gateway cert exists and is ready
          kubectl wait --for=condition=Ready certificate/gateway-tls -n istio-ingress --timeout=60s

      - name: Test ingress routing
        run: |
          echo "Testing HTTPS ingress..."
          # Test with retries since apps may still be starting
          ROUTING_VERIFIED=false
          for i in {1..5}; do
            RESPONSE=$(curl -sk -H "Host: httpbin.localhost" https://localhost:8443/get 2>/dev/null || true)
            if echo "$RESPONSE" | jq -e '.url' >/dev/null 2>&1; then
              echo "✓ HTTPS routing verified"
              ROUTING_VERIFIED=true
              break
            fi
            echo "Retry $i/5..."
            sleep 10
          done

          if [ "$ROUTING_VERIFIED" != "true" ]; then
            echo "✗ HTTPS routing failed after 5 attempts"
            echo "Last response: $RESPONSE"
            exit 1
          fi

          # Verify sidecar injection
          CONTAINERS=$(kubectl get pod -l app=httpbin -n ingress-sample -o jsonpath='{.items[0].spec.containers[*].name}')
          if echo "$CONTAINERS" | grep -q "istio-proxy"; then
            echo "✓ Sidecar injection verified"
          else
            echo "✗ Sidecar injection failed - istio-proxy not found"
            echo "Containers: $CONTAINERS"
            exit 1
          fi

      - name: Test MQTT connectivity
        run: |
          echo "Testing MQTT broker connectivity..."
          MQTT_POD=$(kubectl get pods -n home-automation -l app.kubernetes.io/name=mosquitto -o jsonpath='{.items[0].metadata.name}')
          if [ -z "$MQTT_POD" ]; then
            echo "✗ Mosquitto pod not found"
            exit 1
          fi
          kubectl exec -n home-automation "$MQTT_POD" -c mosquitto -- \
            mosquitto_pub -h localhost -p 1883 -t "ci/test" -m "hello" -q 1
          echo "✓ MQTT connectivity verified"

      - name: Test ArgoCD idempotency
        run: |
          echo "Testing ArgoCD idempotency (re-bootstrap)..."
          make argocd-up
          echo "✓ ArgoCD bootstrap is idempotent"

      # ===== ARGOCD STATUS =====
      - name: Show ArgoCD application status
        if: always()
        run: |
          echo "=== ArgoCD Applications ==="
          kubectl get applications -n argocd 2>/dev/null || echo "No applications found"
          echo ""
          echo "=== Application Health Summary ==="
          kubectl get applications -n argocd -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.status.health.status}{"\t"}{.status.sync.status}{"\n"}{end}' 2>/dev/null || true

      # ===== SUMMARY =====
      - name: Print stack status
        if: always()
        run: |
          echo "=== Final Stack Status ==="
          if ! kubectl get pods -A 2>/dev/null | grep -v "Completed"; then
            echo "Warning: Could not retrieve pod status"
          fi
          echo ""
          echo "=== Helm Releases ==="
          if ! helm list -A 2>/dev/null; then
            echo "Warning: Could not retrieve Helm releases"
          fi

      - name: Cleanup
        if: always()
        run: |
          # ArgoCD manages all resources, just tear down the cluster
          make cluster-down
